```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(data.table)
library(ggplot2)
library(igraph)
library(phyloseq)
library(reshape2)
library(tidyverse)
library(scales)
library(stringr)
library(psych)  #corr.test {psych}
theme_set(theme_light())
```



```{r}
make_pois_community <- function(num_samples = 50, num_otus = 10, lambda = 4, names = "OTU",
                           sites = "Sample", fun = f) {
  matrix(rpois(num_samples * num_otus, lambda),
                        nrow = num_otus, ncol = num_samples,
                        dimnames = list(
                          paste(names, 1:num_otus, sep = "_"),
                          paste(sites, 1:num_samples, sep = "_")
                        )
  
)
}

make_unif_community<- function(num_samples = 50, num_otus = 10, lower = 100, upper = 120, names = "OTU",
                           sites = "Sample", fun = f) {
  matrix(runif(num_samples * num_otus, lower, upper),
                        nrow = num_otus, ncol = num_samples,
                        dimnames = list(
                          paste(names, 1:num_otus, sep = "_"),
                          paste(sites, 1:num_samples, sep = "_")
                        )
  )
}



make_negative_community<- function(num_samples = 50, num_otus = 10, lambda = 4, names = "OTU",
                            sites = "Sample", fun = f){
  matrix(100 - rpois(num_samples * num_otus, lambda),
                        nrow = num_otus, ncol = num_samples,
                        dimnames = list(
                          paste(names, 1:num_otus, sep = "_"),
                          paste(sites, 1:num_samples, sep = "_")
                        )
  )
}

make_positive_community <- function(num_samples = 50, num_otus = 10, lambda = 4, names = "OTU",
                            sites = "Sample", fun = f){
  matrix(2 * rpois(num_samples * num_otus, lambda),
                        nrow = num_otus, ncol = num_samples,
                        dimnames = list(
                          paste(names, 1:num_otus, sep = "_"),
                          paste(sites, 1:num_samples, sep = "_")
                        )
  )
}
  

```


```{r}
comm_1 <- make_pois_community(names = "COMM_A", num_samples = 50, num_otus = 5, lambda = 90)
# comm_2 <- make_unif_community(names = "COMM_B", num_samples = 50, num_otus = 5, lower = 200, upper= 220)
comm_3 <- make_negative_community(names = "COMM_C", num_samples = 50, num_otus = 5, lambda = 90)
comm_4 <- make_positive_community(names = "COMM_D", num_samples = 50, num_otus = 5, lambda = 180)
noise <- make_pois_community(num_otus = 50)
sim_community <- rbind(comm_1, comm_3, comm_4, noise)
```


#getting correlation matrix(OTU BY OTU)
```{r}
sim_community.cor_matrix <- cor(t(sim_community), method = "spearman")
```

#getting correlation matrix with bonferroni correction
```{r}
bonferroni_network <- corr.test(sim_community.cor_matrix, y = NULL, use = "pairwise",method="spearman",adjust="bonferroni",alpha=.05)
```

#selecting only significant OTU Pairs by thresholding p-value <0.01 and correlation values not equal to 1
```{r}
A <- bonferroni_network$r[-1] #dropping correlation values that are 1
B<- bonferroni_network$p
sig_correlation = ifelse (B < 0.01, A , NA) #seletcing p-values smaller than 0.05
```

#correlation plot
```{r}
cor.plot(sig_correlation)
```

#making graph object(example)
```{r}
sim_community.graph <- graph_from_adjacency_matrix(corr.test(sim_community.cor_matrix, y = NULL, use = "pairwise",method="spearman",adjust="holm",alpha=.05)$r, mode = "undirected", weighted = TRUE, diag = FALSE)
```

#making graph object(bonferroni)
```{r}
sim_community.bonf <- graph_from_adjacency_matrix(sig_correlation, mode = "undirected", weighted = TRUE, diag = FALSE)
```

#visualize degree distribution by function plot_dd
```{r more_graph.1}
plot_dd <- function(g){
  g.dd <- data.frame(0:(length(degree_distribution(g)) - 1), 
                     degree_distribution(g, cumulative = FALSE))
  colnames(g.dd) <-c("k", "p_k")
  ggplot(g.dd, aes(x = k, y = p_k)) + geom_bar(stat = "identity") +
    labs(x = "Degree (k)", y = "Proportion of nodes of degree k (p(k))", title = "Degree distribution: k vs. p(k)", 
         subtitle = paste("Graph:", deparse(substitute(g)))) +
    theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) + 
    scale_x_continuous(breaks = function(x) seq(ceiling(x[1]), floor(x[2]), by = 1))
}
```


#thresholding the values of this correlation matrix. We say that two OTUs are *positively correlated* if the Spearman correlation between them is grater than $0.90$.

```{r}
threshold <- sig_correlation
```

Assigning 1 to all the values of the matrix above our cutoff:

```{r}
threshold[threshold <= -0.3] <- -1
```

```{r}
threshold[is.na(threshold)] <- 0
```


```{r}
threshold[threshold >= 0.3] <- 1

```

Doing the same for negatively co

```{r}
threshold[threshold <= -0.3] <- -1

```

Setting everything else to 0 since they don't fall into our definition of positive or negatively correlated:

```{r}
threshold[threshold >= -0.3 & threshold <= 0.3] <- 0
```

```{r}
threshold_graph <- graph_from_adjacency_matrix(threshold, mode ="undirected", diag =FALSE)
```


look at the degree distribution
```{r}

correlation_matrix_copy_graph<- graph_from_adjacency_matrix(corr.test(correlation_matrix_copy, y = NULL, use = "pairwise",method="spearman",adjust="holm",alpha=.05)$r, mode = "undirected", weighted = TRUE, diag = FALSE)
plot_dd(corelation_matrix_copy_graph)
```



#Clustering
```{r}
plot(threshold_graph)
```

```{r}
gorder(threshold_graph)
plot(threshold_graph, 
     # layout = layout_in_circle(threshold_graph),
     layout = layout.fruchterman.reingold(threshold_graph),
     main = "Network")
```




```{r}
threshold_graph.copy <- delete.vertices(threshold_graph, degree(threshold_graph) == 0)
gorder(threshold_graph.copy)
plot(threshold_graph.copy, 
     layout = layout.fruchterman.reingold(threshold_graph.copy),
     main = "Network with isolated nodes removed",
     )
```

```{r}
gorder(threshold_graph.copy)
```


```{r}
plot_dd(threshold_graph.copy)
```


```{r}
correlation_matrix_copy <- sim_community.cor_matrix
fake_quantiles <- list(upper = -0.3, lower = 0.3)
threshold_cor_matrix(correlation_matrix_copy, fake_quantiles)
```


```{r}
plot(sim_community.bonf,
     layout = layout_in_circle(sim_community.bonf))
```

```{r}
plot(sim_community.graph,
     layout = layout_in_circle(sim_community.bonf))
```

```{r}
gorder(sim_community.bonf)
```

Next: want to threshold correlation matrix based on p matrix (ie, threshold `bonferroni_network$r` based on the values in `bonferroni_network$p`)

```{r}
sig_correlation %>% hist ()
```


```{r}
cfg <- cluster_fast_greedy(threshold_graph.copy)
plot(cfg, threshold_graph.copy)

```

